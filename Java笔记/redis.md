# 1、什么是Redis？
##解释一
Redis 是一个使用 C 语言写成的，开源的高性能key-value非关系缓存数据库。
它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和 hash（哈希类型）。
Redis的数据都基于缓存的，所以很快，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。
Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。
##解释二
Redis是一种基于键值对（key-value）的NoSQL数据库。
比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、
Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构，因此 Redis可以满足很多的应用场景。
而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常出色。
不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。
除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。

总之，Redis是一款强大的性能利器。

# 2、Redis有哪些优缺点？
##优点
（1）读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
（2）支持数据持久化，支持AOF和RDB两种持久化方式。
（3）支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
（4）数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
（5）支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
##缺点
（1）数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
（2）Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
（3）主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
（4）Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

# 3、使用redis有哪些好处？
(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都很低；
(2) 支持丰富数据类型，支持string，list，set，sorted set，hash；
![redis_数据类型](/src/main/javaInterview/picture/redis_数据类型.png)
edis有五种基本数据结构。
##string
字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、
数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。
##字符串主要有以下几个典型使用场景：
缓存功能
计数
共享Session
限速
##hash
哈希类型是指键值本身又是一个键值对结构。
哈希主要有以下典型应用场景：
缓存用户信息
缓存对象
##list
列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色
列表主要有以下几种使用场景：
消息队列
文章列表
##set
集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的。
集合主要有如下使用场景：
标签（tag）
共同关注
##sorted set
有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。
有序集合主要应用场景：
用户点赞统计
用户排序
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行；
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除。


# 4、为什么要用 Redis / 为什么要用缓存
主要从“高性能”和“高并发”这两点来看待这个问题。
##高性能：
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。
操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
##高并发：
直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

# 5、为什么要用 Redis 而不用 map/guava 做缓存?
（1）缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，
每个实例都需要各自保存一份缓存，缓存不具有一致性。
（2）使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

# 6、Redis为什么这么快
##解释一
（1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
（2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
（3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
（4）使用多路 I/O 复用模型，非阻塞 IO；
（5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
##解释二
![redis_为什么这么快](/src/main/javaInterview/picture/redis_为什么这么快.png)
Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。
速度快的原因主要有⼏点：
（1）完全基于内存操作；
（2）使⽤单线程，避免了线程切换和竞态产生的消耗；
（3）基于⾮阻塞的IO多路复⽤机制；
（4）C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼。

# 7、Redis的应用场景
##解释一
（1）计数器
可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
（2）缓存
将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
（3）会话缓存
可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，
一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
（4）全页缓存（FPC）
除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。
此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
（5）查找表
例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特
性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。
（6）消息队列(发布/订阅功能)
List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。
（7）分布式锁实现
在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的SETNX 命令实现分布式锁，
除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
（8）其它
Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。

##解释二
![redis_应用场景](/src/main/javaInterview/picture/redis_应用场景.png)
（1）缓存
这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。
![redis_缓存](/src/main/javaInterview/picture/redis_缓存.png)
（2）计数器 
Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等。
（3） 排行榜 
Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。
（4）社交网络 
赞/踩、粉丝、共同好友/喜好、推送、下拉刷新。
（5）消息队列 
Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。
（6）分布式锁 
分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用。

##Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：
Token存储：用户登录成功之后，使用Redis存储Token；
登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号；
地址缓存：对省市区数据的缓存；
分布式锁：分布式环境下登录、注册等操作加分布式锁。


# 8、Redis 的持久化机制是什么？各自的优缺点？
##解释一
持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:
（1）RDB：是Redis DataBase缩写快照
RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。
通过配置文件中的save参数来定义快照的周期。
优点：
1、只有一个文件 dump.rdb，方便持久化。
2、容灾性好，一个文件可以保存到安全的磁盘。
3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单 独子进程来进行持久化，
主进程不会进行任何 IO 操作，保证了 redis 的高性能。
4.相对于数据集大时，比 AOF 的启动效率更高。
缺点：
1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数
据丢失。所以这种方式更适合数据要求不严谨的时候)
2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请求协议的格式
完全持久化存储)保存为 aof 文件。
（2）AOF：持久化：
AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复
优点：
1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重
写），可以删除其中的某些命令（比如误操作的 flushall）)
缺点：
1、AOF 文件比 RDB 文件大，且恢复速度慢。
2、数据集大的时候，比 RDB 启动效率低。
俩种持久化的优缺点是什么？
AOF文件比RDB更新频率高，优先使用AOF还原数据。
AOF比RDB更安全也更大
RDB性能比AOF好
如果两个都配了优先加载AOF
##解释二
###RDB
RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。
RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。
####手动触发分别对应save和bgsave命令:
（1）save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。
（2）bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。
####以下场景会自动触发RDB持久化：
（1）使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave；
（2）如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点；
（3）执行debug reload命令重新加载Redis时，也会自动触发save操作；
（4）默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。
####RDB | 优点
（1）只有一个紧凑的二进制文件 dump.rdb，非常适合备份、全量复制的场景。
（2）容灾性好，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。
（3）恢复速度快，RDB恢复数据的速度远远快于AOF的方式
####RDB | 缺点
实时性低，RDB 是间隔一段时间进行持久化，没法做到实时持久化/秒级持久化。如果在这一间隔事件发生故障，数据会丢失。
存在兼容问题，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。

###AOF
AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。
AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。
AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）
流程如下：
1）所有的写入命令会追加到aof_buf（缓冲区）中。
2）AOF缓冲区根据对应的策略向硬盘做同步操作。
3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。
4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。
####优点
（1）实时性好，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。
（2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
####缺点
AOF 文件比 RDB 文件大，且 恢复速度慢。
数据集大 的时候，比 RDB 启动效率低。

##RDB和AOF如何选择？
（1）一般来说，如果想达到足以媲美数据库的数据安全性，应该同时使用两种持久化功能。
在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。
（2）如果可以接受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。
（3）有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 
并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。
（4）如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式。

##Redis的数据恢复？
当Redis发生了故障，可以从RDB或者AOF中恢复数据。
恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可。
![redis_数据恢复](/src/main/javaInterview/picture/redis_数据恢复.png)
###Redis 启动时加载数据的流程：
（1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。
（2）AOF关闭或者AOF文件不存在时，加载RDB文件。
（3）加载AOF/RDB文件成功后，Redis启动成功。
（4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。

# 9、如何选择合适的持久化方式
（1）一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。
在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF
文件保存的数据集要比RDB文件保存的数据集要完整。
（2）如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。
（3）有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非 常便于进行数据库备份， 
并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。
（4）如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。

# 10、Redis持久化数据和缓存怎么做扩容？
（1）如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
（2）如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。
否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。

# 11、Redis的过期键的删除策略
我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。
过期策略通常有以下三种：
（1）定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。
该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
（2）惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。
极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
（3）定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。
该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 
(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。
键空间是指该Redis集群中保存的所有键。)
##Redis中同时使用了惰性过期和定期过期两种过期策略。
##Redis key的过期时间和永久有效分别怎么设置？ expire和persist命令

# 12、我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?
除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据
具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
（1）定时去清理过期的缓存；
（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断
缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。

# 13、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

# 14、Redis的内存淘汰策略有哪些？
Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
（1）全局的键空间选择性移除
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
（2）设置过期时间的键空间选择性移除
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
总结
##Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。

# 15、Redis的内存用完了会发生什么？
如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

# 16、Redis如何做内存优化？
可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。
尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。
比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。

#事务
# 17、什么是事务？
（1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
（2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

# 18、Redis事务的概念
Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。
在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
##总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

# 19、Redis事务的三个阶段
（1）事务开始 MULTI
（2）命令入队
（3）事务执行 EXEC
##事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队

# 20、事务管理（ACID）概述
（1）原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
（2）一致性（Consistency）
事务前后数据的完整性必须保持一致。
（3）隔离性（Isolation）
多个事务并发执行时，一个事务的执行不应影响其他事务的执行
（4）持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
##Redis的事务总是具有ACID中的**一致性和隔离性**，其他特性是不支持的。
##当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。

# 21、Redis事务支持隔离性吗
Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。
因此，**Redis 的事务是总是带有隔离性的。**

# 22、Redis事务保证原子性吗，支持回滚吗
Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

## 23、Redis事务其他实现
基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，
剩下的命令还是会继续运行完* 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。
但这样会需要额外写代码实现，比较繁琐。


#集群方案
# 24、哨兵模式
![哨兵模式](/src/main/javaInterview/picture/redis_哨兵模式.png)
##哨兵的介绍
sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：
(1)集群监控：负责监控 redis master 和 slave 进程是否正常工作。
(2)消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
(3)故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
(4)配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。
**哨兵用于实现 redis 集群的高可用**，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。
#故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。
#即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。
##哨兵的核心知识
(1)哨兵至少需要 3 个实例，来保证自己的健壮性。
(2)哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。
(3)对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。

# 25、官方Redis Cluster 方案(服务端路由查询)
![redis_Cluster方案](/src/main/javaInterview/picture/redis_Cluster方案.png)
#Redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？
#分布式寻址都有哪些算法？了解一致性 hash 算法吗？
##简介
Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，
而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行
##方案说明
(1)通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位
(2)每份数据分片会存储在多个互为主从的多节点上
(3)数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
(4)同一分片多个节点间的数据不保持一致性
(5)读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
(6)扩容时时需要需要把旧节点的数据迁移一部分到新节点
#在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w的端口号，比如 16379。
#16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、
#故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。

#节点间的内部通信机制
(1)基本通信原理
(2)集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。
#分布式寻址算法
（1）hash 算法（大量缓存重建）
（2）一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）
（3）redis cluster 的 hash slot 算法
#优点
（1）无中心架构，支持动态扩容，对业务透明；
（2）具备Sentinel的监控和自动Failover(故障转移)能力；
（3）客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；
（4）高性能，客户端直连redis服务，免去了proxy代理的损耗。
#缺点
（1）运维也很复杂，数据迁移需要人工干预；
（2）只能使用0号数据库；
（3）不支持批量操作(pipeline管道操作)；
（4）分布式逻辑和存储模块耦合等。

# 26、Redis 主从架构
单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。
因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的slave 节点，从节点负责读。
所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。
![redis_主从架构](/src/main/javaInterview/picture/redis_主从架构.png)
#redis replication -> 主从架构 -> 读写分离 -> 水平扩容支撑读高并发
#redis replication 的核心机制
（1）redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己
每次复制的数据量；
（2）一个 master node 是可以配置多个 slave node 的；
（3）slave node 也可以连接其他的 slave node；
（4）slave node 做复制的时候，不会 block master node 的正常工作；
（5）slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；
但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；
（6）slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。
#注意：
（1）如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为
master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重
启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。
（2）另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb
去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，
slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master
node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。
#redis 主从复制的核心原理
（1）当启动一个 slave node 的时候，它会发送一个  PSYNC 命令给 master node。
（2）如果这是 slave node 初次连接到 master node，那么会触发一次  full resynchronization 全
量复制。此时 master 会启动一个后台线程，开始生成一份  RDB 快照文件，
（3）同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 RDB 文件生成完毕后， master
会将这个  RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，
（4）接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。
（5）slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node
仅会复制给 slave 部分缺少的数据。
![redis_主从复制的核心原理](/src/main/javaInterview/picture/redis_主从复制的核心原理.png)
#过程原理
1. 当从库和主库建立MS关系后，会向主数据库发送SYNC命令
2. 主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存
   起来
3. 当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis
4. 从Redis接收到后，会载入快照文件并且执行收到的缓存的命令
5. 之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致
#缺点
所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决。

# 27、Redis集群的主从复制模型是怎样的？
为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。

# 28、生产环境中的 redis 是怎么部署的？
(1)redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，
每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到
每秒 5 万，5 台机器最多是 25 万读写请求/s。
(2)机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上
生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。
(3)5 台机器对外提供读写，一共有 50g 内存。
(4)因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，
redis 从实例会自动变成主实例继续提供读写服务。
(5)你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据
是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内
存的 50%。目前高峰期每秒就是 3500 左右的请求量。
其实大型的公司，会有基础架构的 team 负责缓存集群的运维。

# 29、说说Redis哈希槽的概念？
Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key
通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

# 30、Redis集群会有写操作丢失吗？为什么？
Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

# 31、Redis集群之间是如何复制的？异步复制
# 32、Redis集群最大节点个数是多少？16384个
# 33、Redis集群如何选择数据库？Redis集群目前无法做数据库选择，默认在0数据库。
# 34、Redis是单线程的，如何提高多核CPU的利用率？
可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无
论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。
# 35、为什么要做Redis分区？
分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只
能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的
网络带宽也会随着计算机和网卡的增加而成倍增长。
# 36、你知道有哪些Redis分区实现方案？
（1）客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。
（2）代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，
然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy
（3）查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。
Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，
而是在客户端的帮助下直接redirected到正确的redis节点。
# 37、Redis分区有什么缺点？
（1）涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同
的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。
（2）同时操作多个key,则不能使用Redis事务.
分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning
granularity is the key, so it is not possible to shard a dataset with a single huge key like a very
big sorted set）
（3）当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收
集RDB / AOF文件。
（4）分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大
（5）程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然
而，有一种预分片的技术也可以较好的解决这个问题。

# 38、什么是redis穿透？

解决方法：
1. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓有效时间可以设置短点，
   如30秒（设置太长会导致正常情况也没法使用）。这样可以防止击用户反复用同一个id暴力攻击；
2. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在
   数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力；

# 39、什么是redis雪崩？

解决方法：
1. redis集群，将原来一个人干的工作，分发给多个人干；
2. 缓存预热（关闭外网访问，先开启mysql，通过预热脚本将热点数据写入缓存中，启动缓存。开启外网服务）；
3. 数据不要设置相同的生存时间，不然过期时，redis压力会大。

# 40、什么是redis穿透？

解决方法：
1. 分级缓存（缓存两份数据，第二份数据生存时间长一点作为备份，第一份数据用于被请求命中，
   如果第二份数据被命中说明第一份数据已经过期，要去mysql请求数据重新缓存两份数据）；
2. 计划任务（假如数据生存时间为30分钟，计划任务就20分钟执行一次更新缓存数据）。

# 41、缓存预热
缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，
先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
解决方案：
1. 直接写个缓存刷新页面，上线时手工操作一下；
2. 数据量不大，可以在项目启动的时候自动进行加载；
3. 定时刷新缓存；

# 42、缓存降级
1、当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，
即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
2、缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购 物车、结算）。
3、在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；
比如可以参考日志级别设置预案：
（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降，并发送告警；
（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承的最大阀值，
此时可以根据情况自动降级或者人工降级；
（4）重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
4、服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不要的缓存数据，
可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去据库查询，而是直接返回默认值给用户。

# 43、缓存热点key
缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，
这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
解决方案：
对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，
然后等解锁后返回数据或者进入DB查询。

# 44、如何保证缓存与数据库双写时的数据一致性？
（1）一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，
最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况；
（2）串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。
（3）还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是**先更新数据库，然后再删除缓存。**

# 45、Redis如何做大量数据插入？
Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。

# 46、假如Redis里面有1亿个key，其中有10w个key是以某个固定的，已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。
#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，
直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，
但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

# 47、使用Redis做过异步队列吗，是如何实现的？
使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段
时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直
阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当
然也存在一定的缺点，当消费者下线时，生产的消息会丢失。

# 48、能说一下I/O多路复用吗？
引用知乎上一个高赞的回答来解释什么是I/O多路复用。
假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：
第一种选择：
按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。
这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。
第二种选择：
你创建30个分身，每个分身检查一个学生的答案是否正确。
这种类似于为每一个用户创建一个进程或者线程处理连接。
第三种选择：
你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。
此时E、A又举手，然后去处理E和A。

第一种就是阻塞IO模型
![redis_阻塞IO模型](/src/main/javaInterview/picture/redis_阻塞IO模型.png)
第三种就是I/O复用模型。
![redis_IO复用模型](/src/main/javaInterview/picture/redis_IO复用模型.png)
##Linux系统有三种方式实现IO多路复用：select、poll和epoll。
例如epoll方式是将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。
这样，整个过程只在进行select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。

# 49、Redis6.0使用多线程是怎么回事?
Redis不是说用单线程的吗？怎么6.0成了多线程的？
Redis6.0的多线程是用多线程来处理数据的读写和协议解析，但是Redis执行命令还是单线程的。
![redis_多线程](/src/main/javaInterview/picture/redis_多线程.png)
这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。

